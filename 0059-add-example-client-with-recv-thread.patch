From 7c7ad6e99e840f18aca356786dc18542b55ab10e Mon Sep 17 00:00:00 2001
From: houmingyong <houmingyong@huawei.com>
Date: Wed, 8 Mar 2023 20:22:05 +0800
Subject: [PATCH 1/2] add example client with recv thread

---
 .../client/secure_channel_client.c            |   7 +-
 examples/secure_channel/CMakeLists.txt        |   1 +
 examples/secure_channel/client/client.c       |   5 +-
 .../client_with_recv_thread/CMakeLists.txt    |  60 +++++++
 .../client_with_recv_thread/client.c          | 146 ++++++++++++++++++
 examples/secure_channel/host/server.c         |   5 +-
 6 files changed, 217 insertions(+), 7 deletions(-)
 create mode 100644 examples/secure_channel/client_with_recv_thread/CMakeLists.txt
 create mode 100644 examples/secure_channel/client_with_recv_thread/client.c

diff --git a/component/secure_channel/client/secure_channel_client.c b/component/secure_channel/client/secure_channel_client.c
index f4207cf..e22112b 100644
--- a/component/secure_channel/client/secure_channel_client.c
+++ b/component/secure_channel/client/secure_channel_client.c
@@ -164,7 +164,7 @@ void cc_sec_chl_client_fini(cc_sec_chl_ctx_t *ctx)
 
 cc_enclave_result_t cc_sec_chl_client_callback(cc_sec_chl_ctx_t *ctx, void *buf, size_t len)
 {
-    if (ctx == NULL || buf == NULL || len == 0) {
+    if (ctx == NULL || ctx->handle == NULL || buf == NULL || len == 0) {
         return CC_ERROR_BAD_PARAMETERS;
     }
     if (len > SEC_CHL_RECV_BUF_MAX_LEN) {
@@ -210,6 +210,7 @@ static cc_enclave_result_t recv_svr_pubkey(cc_sec_chl_ctx_t *ctx)
     memcpy(ctx->handle->svr_pubkey, msg->data, msg->data_len);
     ctx->handle->svr_pubkey_len = msg->data_len;
     ctx->session_id = msg->session_id;
+    ctx->handle->recv_buf_len = 0;
     pthread_mutex_unlock(&ctx->handle->lock);
 
     return CC_SUCCESS;
@@ -288,6 +289,7 @@ static cc_enclave_result_t recv_svr_param(cc_sec_chl_ctx_t *ctx)
     memcpy(ecdh_ctx->svr_exch_param_buf, msg->data, msg->data_len);
     ecdh_ctx->svr_exch_param_buf_len = msg->data_len;
     ctx->handle->ecdh_ctx = ecdh_ctx;
+    ctx->handle->recv_buf_len = 0;
 
     pthread_mutex_unlock(&ctx->handle->lock);
 
@@ -337,6 +339,7 @@ static cc_enclave_result_t recv_set_param_ret(cc_sec_chl_ctx_t *ctx)
     }
     msg = (sec_chl_msg_t *)ctx->handle->recv_buf;
     ret = msg->ret;
+    ctx->handle->recv_buf_len = 0;
     pthread_mutex_unlock(&ctx->handle->lock);
 
     return ret;
@@ -386,7 +389,7 @@ static sec_chl_fsm_state_transform_t g_state_transform_table[] = {
     {STATE_ALL_READY, EVENT_COMPUTE_SESSIONKEY, STATE_SUCCESS, sec_chl_compute_session_key},
 };
 
-#define RECV_MSG_TIMEOUT_CNT 30
+#define RECV_MSG_TIMEOUT_CNT 1000
 #define RECV_MSG_INTERVAL (60 * 1000)
 cc_enclave_result_t sec_chl_run_fsm(cc_sec_chl_ctx_t *ctx)
 {
diff --git a/examples/secure_channel/CMakeLists.txt b/examples/secure_channel/CMakeLists.txt
index 0bf8565..98ebd17 100644
--- a/examples/secure_channel/CMakeLists.txt
+++ b/examples/secure_channel/CMakeLists.txt
@@ -24,3 +24,4 @@ endif()
 add_subdirectory(${CURRENT_ROOT_PATH}/enclave)
 add_subdirectory(${CURRENT_ROOT_PATH}/host)
 add_subdirectory(${CURRENT_ROOT_PATH}/client)
+add_subdirectory(${CURRENT_ROOT_PATH}/client_with_recv_thread)
diff --git a/examples/secure_channel/client/client.c b/examples/secure_channel/client/client.c
index 1c9d885..466aaa5 100644
--- a/examples/secure_channel/client/client.c
+++ b/examples/secure_channel/client/client.c
@@ -74,7 +74,7 @@ int main(int argc, char **argv)
         goto finish;
     }
 
-    // step3: 安全通道初始化完成后，调用加密接口加密业务数据
+    // step2: 安全通道初始化完成后，调用加密接口加密业务数据
     char *client_secret = "This is client secret 666";
     printf("client send secret:%s\n\n", client_secret);
 
@@ -96,7 +96,7 @@ int main(int argc, char **argv)
         goto finish;
     }
 
-    // step4: 加密后，用户结合自己业务发送到服务端enclave中，调用解密接口解密
+    // step3: 加密后，用户结合自己业务发送到服务端enclave中，调用解密接口解密
     size_t msg_len = sizeof(usr_msg_t) + encrypt_len;
     usr_msg_t *msg = calloc(1, msg_len);
     if (msg == NULL) {
@@ -131,7 +131,6 @@ int main(int argc, char **argv)
 
   finish:
     cc_sec_chl_client_fini(&g_ctx);
-    pthread_exit(NULL);
     close(sockfd);
     return 0;
 }
diff --git a/examples/secure_channel/client_with_recv_thread/CMakeLists.txt b/examples/secure_channel/client_with_recv_thread/CMakeLists.txt
new file mode 100644
index 0000000..b6e69c6
--- /dev/null
+++ b/examples/secure_channel/client_with_recv_thread/CMakeLists.txt
@@ -0,0 +1,60 @@
+#set host exec name
+set(OUTPUT sc_client_with_recv_thread)
+#set host src code
+set(SOURCE_FILE ${CMAKE_CURRENT_SOURCE_DIR}/client.c)
+
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-maybe-uninitialized -fPIE")
+
+if(CC_GP)
+    if(${CMAKE_VERSION} VERSION_LESS "3.13.0")
+        link_directories(${CMAKE_LIBRARY_OUTPUT_DIRECTORY})
+    endif()
+    add_executable(${OUTPUT} ${SOURCE_FILE} ${AUTO_FILES})
+    target_include_directories(${OUTPUT} PRIVATE
+            ${CMAKE_CURRENT_BINARY_DIR}
+            ${CMAKE_BINARY_DIR}/inc
+            ${CMAKE_CURRENT_SOURCE_DIR}/..
+            /usr/include/secGear)
+    if(${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.13.0")
+        target_link_directories(${OUTPUT} PRIVATE ${CMAKE_LIBRARY_OUTPUT_DIRECTORY})
+    endif()
+    target_link_libraries(${OUTPUT} secgear pthread csecure_channel)
+endif()
+
+if(CC_SGX)
+    if(${CMAKE_VERSION} VERSION_LESS "3.13.0")
+        link_directories(${CMAKE_LIBRARY_OUTPUT_DIRECTORY} ${SGX_SDK_PATH}/lib64)
+    endif()
+    set(SGX_MODE HW)
+    set(COMMON_CFLAGS "-m64")
+    add_executable(${OUTPUT} ${SOURCE_FILE} ${AUTO_FILES})
+    target_include_directories(${OUTPUT} PRIVATE
+        ${CMAKE_CURRENT_BINARY_DIR}
+        ${CMAKE_CURRENT_SOURCE_DIR}/..
+        ${LOCAL_ROOT_PATH}/inc/host_inc
+        ${LOCAL_ROOT_PATH}/inc/host_inc/sgx
+        ${LOCAL_ROOT_PATH}/component/secure_channel
+        ${LOCAL_ROOT_PATH}/component/secure_channel/client)
+    if(${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.13.0")
+        target_link_directories(${OUTPUT} PRIVATE ${CMAKE_LIBRARY_OUTPUT_DIRECTORY} ${SGX_SDK_PATH}/lib64)
+    endif()
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${host_C_Flags}")
+    target_link_libraries(${OUTPUT} secgear csecure_channel pthread ssl crypto)
+endif()
+
+set_target_properties(${OUTPUT} PROPERTIES SKIP_BUILD_RPATH TRUE)
+
+if(CC_GP)
+    install(TARGETS  ${OUTPUT}
+            RUNTIME
+            DESTINATION /vendor/bin/
+            PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ)
+endif()
+
+if(CC_SGX)
+    install(TARGETS  ${OUTPUT}
+            RUNTIME
+            DESTINATION ${CMAKE_BINARY_DIR}/bin/
+            PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ)
+endif()
diff --git a/examples/secure_channel/client_with_recv_thread/client.c b/examples/secure_channel/client_with_recv_thread/client.c
new file mode 100644
index 0000000..73960e5
--- /dev/null
+++ b/examples/secure_channel/client_with_recv_thread/client.c
@@ -0,0 +1,146 @@
+#include <stdio.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <openssl/ec.h>
+#include <string.h>
+#include "status.h"
+
+#include "usr_msg.h"
+#include "secure_channel_client.h"
+
+
+#define MAXBUF 1024
+cc_sec_chl_ctx_t g_ctx = {0};
+
+void *recv_msg_thread(void *arg)
+{
+    (void)arg;
+    cc_sec_chl_ctx_t *ctx = &g_ctx;
+    int fd = *(int *)(ctx->conn_kit.conn);
+    int len;
+    uint8_t buf[MAXBUF] = {0};
+    int ret;
+    uint8_t plain[MAXBUF] = {0};
+    size_t plain_len = MAXBUF;
+
+    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL); // 收到cancel信号后，state设置为CANCELED状态
+    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL); // 退出形式为立即退出
+
+    while (1) {
+        pthread_testcancel();
+        len = read(fd, buf, MAXBUF);
+        if (len <= 0) {
+            printf("receive no data\n");
+            sleep(1);
+            continue;
+        }
+        usr_msg_t *msg = calloc(1, len);
+        memcpy(msg, buf, len);
+        switch (msg->type) {
+            case MSG_TYPE_SEC_CHL_ESTABLISH:
+                // step2: 在业务的消息接手函数中，调用安全通道客户端回调函数
+                ret = cc_sec_chl_client_callback(ctx, msg->data, msg->len);
+                break;
+            case MSG_TYPE_TEST:
+                // step5: 接收到server enclave中发送过来的数据
+                ret = cc_sec_chl_client_decrypt(ctx, msg->data, msg->len, plain, &plain_len);
+                if (ret != 0) {
+                    printf("client decrypt error\n");
+                }
+                printf("client recv secret:%s\n", plain);
+                break;
+            default:
+                printf("client recv error msg type\n");
+                break;
+        }
+        free(msg);
+    }
+    return NULL;
+}
+
+int main(int argc, char **argv)
+{
+    (void)argc;
+    (void)argv;
+    int sockfd;
+    cc_enclave_result_t ret;
+    struct sockaddr_in svr_addr;
+
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sockfd == -1) {
+        printf("create socket failed\n");
+        return -1;
+    }
+    bzero(&svr_addr, sizeof(svr_addr));
+    svr_addr.sin_family = AF_INET;
+    svr_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    svr_addr.sin_port = htons(12306);
+
+    if (connect(sockfd, (struct sockaddr *)&svr_addr, sizeof(svr_addr)) != 0) {
+        printf("connet to server failed\n");
+        close(sockfd);
+        return -1;
+    }
+    printf("connect server success\n");
+
+    // step1: 初始化安全通道客户端，注册消息发送函数
+    g_ctx.conn_kit.send = (void *)socket_write_adpt;
+    g_ctx.conn_kit.conn = &sockfd;
+
+    pthread_t thread;
+    pthread_create(&thread, NULL, recv_msg_thread, NULL);
+
+    ret = cc_sec_chl_client_init(CC_SEC_CHL_ALGO_RSA_ECDH_AES_GCM, &g_ctx);
+    if (ret != CC_SUCCESS) {
+        printf("secure channel init failed:%u\n", ret);
+        goto finish;
+    }
+
+    // step2: 安全通道初始化完成后，调用加密接口加密业务数据
+    char *client_secret = "This is client secret 666";
+    printf("client send secret:%s\n\n", client_secret);
+
+    char *encrypted = NULL;
+    size_t encrypt_len = 0;
+    ret = cc_sec_chl_client_encrypt(&g_ctx, (void *)client_secret, strlen(client_secret),
+        encrypted, &encrypt_len);
+    if (ret == CC_ERROR_SEC_CHL_LEN_NOT_ENOUGH) {
+        encrypted = (char *)calloc(1, encrypt_len);
+        if (encrypted == NULL) {
+            goto finish;
+        }
+    }
+    ret = cc_sec_chl_client_encrypt(&g_ctx, (void *)client_secret, strlen(client_secret), encrypted, &encrypt_len);
+    if (ret != CC_SUCCESS) {
+        printf("client encrypt secret failed:%u\n", ret);
+        free(encrypted);
+        encrypted = NULL;
+        goto finish;
+    }
+
+    // step3: 加密后，用户结合自己业务发送到服务端enclave中，调用解密接口解密
+    size_t msg_len = sizeof(usr_msg_t) + encrypt_len;
+    usr_msg_t *msg = calloc(1, msg_len);
+    msg->type = MSG_TYPE_TEST;
+    msg->session = g_ctx.session_id;
+    msg->len = encrypt_len;
+    memcpy(msg->data, encrypted, encrypt_len);
+
+    int result = write(sockfd, (void *)msg, msg_len);
+    if (result < 0) {
+        printf("send msg error\n");
+    }
+    free(msg);
+    free(encrypted);
+
+    sleep(2); // 等收到enclave加密消息后，再结束安全通道
+
+  finish:
+    cc_sec_chl_client_fini(&g_ctx);
+    pthread_cancel(thread);
+    close(sockfd);
+    return 0;
+}
+
+
diff --git a/examples/secure_channel/host/server.c b/examples/secure_channel/host/server.c
index db7b156..0b0f5ad 100644
--- a/examples/secure_channel/host/server.c
+++ b/examples/secure_channel/host/server.c
@@ -17,9 +17,10 @@ int main(int argc, char **argv)
 {
     (void)argc;
     (void)argv;
-    uint32_t len;
+    int len;
     int sockfd, connfd;
     struct sockaddr_in svr_addr, conn_addr;
+    uint32_t conn_len = sizeof(conn_addr);
     char buf[MAXBUF + 1] = {0};
 
     sockfd = socket(AF_INET, SOCK_STREAM, 0);
@@ -62,7 +63,7 @@ int main(int argc, char **argv)
     ret = cc_sec_chl_svr_init(&svr_ctx);
 
     while (1) {
-        connfd = accept(sockfd, (struct sockaddr *)&conn_addr, &len);
+        connfd = accept(sockfd, (struct sockaddr *)&conn_addr, &conn_len);
         if (connfd < 0) {
             printf("accept error\n");
             continue;
-- 
2.33.0

